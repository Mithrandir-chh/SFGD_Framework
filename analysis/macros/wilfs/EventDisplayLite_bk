// EventDisplayLite.cpp - Simple event display for SFGD detector
// Compatible with the SFGD framework build system

#define THIS_NAME EventDisplayLite
#define OVERRIDE_OPTIONS

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include "TFile.h"
#include "TTree.h"
#include "TH2F.h"
#include "TH1F.h"
#include "TCanvas.h"
#include "TStyle.h"
#include "TClonesArray.h"
#include "TROOT.h"
#include "TSystem.h"
#include "TPaveText.h"
#include "TApplication.h"

// Include the framework headers FIRST (before defining any globals)
#include "../../src/tools/global_header.hh"

using namespace std;

// Global parameters for the detector geometry
const int DETECTOR_X = 24;  // X dimension in units
const int DETECTOR_Y = 8;   // Y dimension in units  
const int DETECTOR_Z = 48;  // Z dimension in units

// Main function following framework convention
void EventDisplayLite() {
    
    // Default values
    TString fileIn = "";
    TString fileOut = "event_display.root";
    int evtIni = 0;
    int evtFin = -1;
    int minHits = 15;
    bool batch = true;
    bool saveImages = true;
    TString imageDir = "./";
    
    // Get command line arguments from the global application
    int argc = gApplication->Argc();
    char** argv = gApplication->Argv();
    
    // Parse command line arguments
    for (int iarg = 0; iarg < argc; iarg++) {
        string arg = argv[iarg];
        
        if (arg == "-h" || arg == "--help") {
            cout << "Simple Event Display for SFGD Detector\n";
            cout << "Usage: " << argv[0] << " -i input.root [options]\n";
            cout << "Options:\n";
            cout << "  -i, --input FILE     Input ROOT file (required)\n";
            cout << "  -o, --output FILE    Output ROOT file (default: event_display.root)\n";
            cout << "  -a, --evtIni N       Start event number (default: 0)\n";
            cout << "  -z, --evtFin N       End event number (default: all events)\n";
            cout << "  -m, --minhits N      Minimum hits to display event (default: 15)\n";
            cout << "  -b, --batch          Run in batch mode (no display)\n";
            cout << "  --save-images        Save PNG images of events\n";
            cout << "  --image-dir DIR      Directory for saving images (default: ./)\n";
            cout << "  -h, --help           Show this help message\n";
            return;
        }
        else if ((arg == "-i" || arg == "--input") && iarg + 1 < argc) {
            iarg++;
            fileIn = argv[iarg];
        }
        else if ((arg == "-o" || arg == "--output") && iarg + 1 < argc) {
            iarg++;
            fileOut = argv[iarg];
        }
        else if ((arg == "-a" || arg == "--evtIni") && iarg + 1 < argc) {
            iarg++;
            evtIni = atoi(argv[iarg]);
        }
        else if ((arg == "-z" || arg == "--evtFin") && iarg + 1 < argc) {
            iarg++;
            evtFin = atoi(argv[iarg]);
        }
        else if ((arg == "-m" || arg == "--minhits") && iarg + 1 < argc) {
            iarg++;
            minHits = atoi(argv[iarg]);
        }
        else if (arg == "-b" || arg == "--batch") {
            batch = true;
            gROOT->SetBatch(kTRUE);
        }
        else if (arg == "--save-images") {
            saveImages = true;
        }
        else if (arg == "--image-dir" && iarg + 1 < argc) {
            iarg++;
            imageDir = argv[iarg];
            // Ensure directory ends with /
            if (!imageDir.EndsWith("/")) imageDir += "/";
        }
    }
    
    // Check if input file was provided
    if (fileIn == "") {
        cerr << "Error: Input file is required. Use -h for help.\n";
        return;
    }
    
    // Set up output paths based on input file location
    TString inputDir = gSystem->DirName(fileIn);
    TString inputBaseName = gSystem->BaseName(fileIn);
    inputBaseName.ReplaceAll(".root", "");
    
    // If no output file specified, create it in the same directory as input
    if (fileOut == "event_display.root") {
        fileOut = inputDir + "/" + inputBaseName + "_display.root";
    }
    
    // Set up image directory
    if (saveImages && imageDir == "./") {
        imageDir = inputDir + "/EventDisplay_PNG/";
    }
    
    // Create image directory if saving images
    if (saveImages) {
        gSystem->mkdir(imageDir, kTRUE);  // kTRUE = create parent directories if needed
        cout << "PNG files will be saved to: " << imageDir << endl;
    }
    
    // Set style
    gStyle->SetOptStat(0);
    gStyle->SetPalette(kRainBow);
    
    cout << "Input file: " << fileIn << endl;
    cout << "Output file: " << fileOut << endl;
    
    // Open input file
    TFile* fInput = TFile::Open(fileIn, "READ");
    if (!fInput || fInput->IsZombie()) {
        cerr << "Error: Cannot open input file: " << fileIn << endl;
        return;
    }
    
    // Get the event tree - try both possible tree names
    TTree* eventTree = (TTree*)fInput->Get("TimeGroupedEvents");
    if (!eventTree) {
        eventTree = (TTree*)fInput->Get("AllEvents");
    }
    
    if (!eventTree) {
        cerr << "Error: Cannot find event tree in input file" << endl;
        fInput->Close();
        return;
    }
    
    // Create event object and set branch address
    Event* event = new Event();
    eventTree->SetBranchAddress("Event", &event);
    
    // Open output file
    TFile* fOutput = new TFile(fileOut, "RECREATE");
    if (!fOutput || fOutput->IsZombie()) {
        cerr << "Error: Cannot create output file: " << fileOut << endl;
        fInput->Close();
        return;
    }
    
    // Create histograms
    TH2F* hXY = new TH2F("hXY", "XY View;X [channels];Y [channels];Charge [PE]", 
                         DETECTOR_X, 0, DETECTOR_X, DETECTOR_Y, 0, DETECTOR_Y);
    TH2F* hXZ = new TH2F("hXZ", "XZ View;X [channels];Z [channels];Charge [PE]", 
                         DETECTOR_X, 0, DETECTOR_X, DETECTOR_Z, 0, DETECTOR_Z);
    TH2F* hZY = new TH2F("hZY", "ZY View;Z [channels];Y [channels];Charge [PE]", 
                         DETECTOR_Z, 0, DETECTOR_Z, DETECTOR_Y, 0, DETECTOR_Y);
    
    // Summary histograms
    TH1F* hHitMultiplicity = new TH1F("hHitMultiplicity", 
                                      "Hit Multiplicity;Number of Hits;Events", 
                                      100, 0, 100);
    TH1F* hTotalCharge = new TH1F("hTotalCharge", 
                                   "Total Event Charge;Total Charge [PE];Events", 
                                   200, 0, 2000);
    TH1F* hMaxCharge = new TH1F("hMaxCharge", 
                                "Maximum Hit Charge;Max Charge [PE];Events", 
                                200, 0, 200);
    
    hXY->SetDirectory(nullptr);
    hXZ->SetDirectory(nullptr);
    hZY->SetDirectory(nullptr);
    hHitMultiplicity->SetDirectory(nullptr);
    hTotalCharge->SetDirectory(nullptr);
    hMaxCharge->SetDirectory(nullptr);

    // Get number of events
    Long64_t nEvents = eventTree->GetEntries();
    cout << "Total events in file: " << nEvents << endl;
    
    // Set event range
    if (evtFin < 0 || evtFin > nEvents) evtFin = nEvents;
    
    cout << "Processing events " << evtIni << " to " << evtFin - 1 << endl;
    cout << "Event selection criteria:" << endl;
    cout << "  - Minimum hits: " << minHits << endl;
    
    // Create canvas for interactive display
    TCanvas* canvas = canvas = new TCanvas("EventDisplay", "SFGD Event Display", 1200, 900);
    canvas->Divide(2, 2);
    
    // Counters
    int nProcessedEvents = 0;
    int nDisplayedEvents = 0;
    
    // Event loop
    for (int iEvent = evtIni; iEvent < evtFin; iEvent++) {
        eventTree->GetEntry(iEvent);
        
        if (iEvent % 100 == 0) {
            cout << "Processing event " << iEvent << " (" 
                 << (100.0 * (iEvent - evtIni) / (evtFin - evtIni)) 
                 << "% done) - Displayed: " << nDisplayedEvents << "\r" << flush;
        }
        
        nProcessedEvents++;
        
        // Clear histograms
        hXY->Reset();
        hXZ->Reset();
        hZY->Reset();
        
        // Process hits
        int nHits = 0;
        double totalCharge = 0;
        double maxCharge = 0;
        
        TClonesArray* hits = event->GetHits();
        if (!hits) continue;
        
        for (int iHit = 0; iHit < hits->GetEntries(); iHit++) {
            Hit* hit = (Hit*)hits->At(iHit);
            if (!hit) continue;
            
            double charge = hit->GetPE();
            // No threshold - display ALL hits that were saved in the event
            
            nHits++;
            totalCharge += charge;
            if (charge > maxCharge) maxCharge = charge;
            
            // Fill appropriate histogram based on view
            if (hit->GetView() == 0) {  // XY view
                hXY->Fill(hit->GetX(), hit->GetY(), charge);
            }
            else if (hit->GetView() == 1) {  // XZ view
                hXZ->Fill(hit->GetX(), hit->GetZ(), charge);
            }
            else if (hit->GetView() == 2) {  // ZY view
                hZY->Fill(hit->GetZ(), hit->GetY(), charge);
            }
        }
        
        // Apply event selection filter
        if (nHits < minHits) {
            continue;  // Skip this event
        }
        
        // Fill summary histograms only for events passing the filter
        hHitMultiplicity->Fill(nHits);
        hTotalCharge->Fill(totalCharge);
        hMaxCharge->Fill(maxCharge);
        
        nDisplayedEvents++;
        
        // Display event if we're not in batch mode
        if (canvas) {
            canvas->cd(1);
            hXY->Draw("COLZ");
            gPad->SetRightMargin(0.15);
            
            canvas->cd(2);
            hXZ->Draw("COLZ");
            gPad->SetRightMargin(0.15);
            
            canvas->cd(3);
            hZY->Draw("COLZ");
            gPad->SetRightMargin(0.15);
            
            canvas->cd(4);
            TPaveText* info = new TPaveText(0.1, 0.1, 0.9, 0.9, "NDC");
            info->AddText(Form("Event: %d", iEvent));
            info->AddText(Form("Total hits: %d", nHits));
            info->AddText(Form("Max charge: %.1f PE", maxCharge));
            info->AddText(Form("Total charge: %.1f PE", totalCharge));
            info->AddText(Form("Displayed event #%d", nDisplayedEvents));
            info->Draw();
            
            canvas->Update();
            
            // Save image if requested
            if (saveImages) {
                TString imageName = Form("%sevent_%06d.png", imageDir.Data(), iEvent);
                canvas->SaveAs(imageName);
            }
            
            // // Wait for user input in interactive mode
            // if (!batch && !saveImages) {
            //     cout << "\nEvent " << iEvent << " - Press Enter to continue, 'q' to quit: ";
            //     string input;
            //     getline(cin, input);
            //     if (input == "q" || input == "Q") {
            //         delete info;
            //         break;
            //     }
            // }
            
            delete info;
        }
        
        // Save event histograms to file
        fOutput->cd();
        hXY->Write(Form("Event%06d_XY", iEvent));
        hXZ->Write(Form("Event%06d_XZ", iEvent));
        hZY->Write(Form("Event%06d_ZY", iEvent));
    }
    
    cout << "\nProcessing complete!" << endl;
    cout << "Total events processed: " << nProcessedEvents << endl;
    cout << "Events passing filter: " << nDisplayedEvents << endl;
    cout << "Events rejected: " << (nProcessedEvents - nDisplayedEvents) << endl;
    
    // Save summary histograms
    fOutput->cd();
    hHitMultiplicity->Write();
    hTotalCharge->Write();
    hMaxCharge->Write();
    
    // Cleanup
    fOutput->Close();
    fInput->Close();
    
    delete event;
    delete hXY;
    delete hXZ;
    delete hZY;
    delete hHitMultiplicity;
    delete hTotalCharge;
    delete hMaxCharge;
    if (canvas) delete canvas;
    
    cout << "Output saved to: " << fileOut << endl; exit(0);
}