#define THIS_NAME EventDisplays_3D_Side
#define OVERRIDE_OPTIONS

// Include the structures header
#include "../../src/HitsRecon_Analysis/Hits3D_Reconstruction.hh"

// Include ROOT and framework headers
#include "TFile.h"
#include "TTree.h"
#include "TH3F.h"
#include "TClonesArray.h"
#include "TSystem.h"
#include "TROOT.h"
#include "TPolyLine3D.h"
#include "TVector3.h"
#include "TVectorD.h"
#include "TMatrixD.h"
#include "TF1.h"
#include "TMath.h"
#include "TStyle.h"
#include "TNamed.h"
#include "../../src/tools/global_header.hh"

using namespace std;

void EventDisplays_3D_Side() {
    gROOT->SetBatch(kTRUE);
    
    // Get command line arguments
    int argc = gApplication->Argc();
    char** argv = gApplication->Argv();

    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <input_file.root> <event_number>" << std::endl;
        return;
    }
    
    TString inputFile = argv[1];
    int eventNumber = atoi(argv[2]);
    
    // Load calibration
    CalibrationData calibData;
    calibData.LoadCalibration("/media/disk_b/standard_software/sfgd_framework/analysis/src/tools/gain_calibration.txt");
    
    // Open file and get event
    TFile* file = TFile::Open(inputFile, "READ");
    if (!file || file->IsZombie()) {
        std::cerr << "Error: Cannot open file " << inputFile << std::endl;
        return;
    }
    
    TTree* tree = (TTree*)file->Get("TimeGroupedEvents");
    if (!tree) {
        std::cerr << "Error: Cannot find TimeGroupedEvents tree" << std::endl;
        file->Close();
        return;
    }
    
    Event* event = new Event();
    tree->SetBranchAddress("Event", &event);
    tree->GetEntry(eventNumber);
    
    std::cout << "Total 2D hits in event: " << event->GetNHits() << std::endl;
    
    // === Use the refactored functions ===
    
    // 1. Reconstruct 3D hits
    std::vector<Hit3D> hits3D = reconstructHits(event, calibData);
    
    // 2. Fit trajectory
    TrajectoryParams trajectory = fitTrajectory(hits3D);
    
    // 3. Perform PCA analysis
    PCATrajectoryResult pcaResult = performPCA(hits3D, 0.5);
    
    // 4. Check if single track
    bool isSingleTrack = false;
    if (pcaResult.valid) {
        isSingleTrack = isSingleTrackEvent(pcaResult);
    }
    
    // 5. Print summary
    printSummary(hits3D, event->GetEventID());
    
    // 6. Create output directory
   // Create output directory
    TString outputDir = createOutputDirectory(inputFile, isSingleTrack);
    TString inputBaseName = gSystem->BaseName(inputFile);
    inputBaseName.ReplaceAll(".root", "");
    
    // Create output filename (simple version)
    TString trackTag = isSingleTrack ? "SingleTrack" : "Other";
    TString outputFile = Form("%s/%s_3D_event%d_Trj_GroupResSide_%s.root", 
                             outputDir.Data(), inputBaseName.Data(), eventNumber, 
                             trackTag.Data());
    
    // Create output file
    TFile* fOutput = new TFile(outputFile, "RECREATE");
    if (!fOutput || fOutput->IsZombie()) {
        std::cerr << "Error: Cannot create output file " << outputFile << std::endl;
        file->Close();
        return;
    }
    
    // Create TH3 histograms for different hit types
    TH3F* h3D_Full = new TH3F("h3D_Full", 
                          Form("Event %d - Full 3D Matches (3 views);Z [cm];Y [cm];X [cm]", eventNumber),
                          48, 0, 48, 8, 0, 8, 24, 0, 24);

    TH3F* h3D_GroupResolved = new TH3F("h3D_GroupResolved", 
                                     Form("Event %d - Group-Resolved 3D Hits;Z [cm];Y [cm];X [cm]", eventNumber),
                                     48, 0, 48, 8, 0, 8, 24, 0, 24);

    TH3F* h3D_Partial = new TH3F("h3D_Partial", 
                             Form("Event %d - Partial 3D Matches (2 views);Z [cm];Y [cm];X [cm]", eventNumber),
                             48, 0, 48, 8, 0, 8, 24, 0, 24);

    TH3F* h3D_All = new TH3F("h3D_All", 
                         Form("Event %d - All 3D Matches;Z [cm];Y [cm];X [cm]", eventNumber),
                         48, 0, 48, 8, 0, 8, 24, 0, 24);

    TH3F* h3D_Alpha = new TH3F("h3D_Alpha", 
                           Form("Event %d - Hit Confidence Levels;Z [cm];Y [cm];X [cm]", eventNumber),
                           48, 0, 48, 8, 0, 8, 24, 0, 24);

    // Fill histograms with charge as weight and confidence as alpha
    for (const auto& hit : hits3D) {
        int binZ = h3D_All->GetXaxis()->FindBin(hit.z);
        int binY = h3D_All->GetYaxis()->FindBin(hit.y);
        int binX = h3D_All->GetZaxis()->FindBin(hit.x);
        
        h3D_All->SetBinContent(binZ, binY, binX, hit.charge);
        h3D_Alpha->SetBinContent(binZ, binY, binX, hit.confidence);
        
        if (hit.confidence >= 1.0) {
            h3D_Full->SetBinContent(binZ, binY, binX, hit.charge);
        } else if (hit.matchType.find("Resolved") != std::string::npos) {
            h3D_GroupResolved->SetBinContent(binZ, binY, binX, hit.charge);
        } else {
            h3D_Partial->SetBinContent(binZ, binY, binX, hit.charge);
        }
    }

    // Set up color palette for charge visualization
    gStyle->SetPalette(kViridis);

    // Configure histogram display properties
    h3D_All->SetOption("BOX2Z");
    h3D_Full->SetOption("BOX2Z");
    h3D_GroupResolved->SetOption("BOX2Z");
    h3D_Partial->SetOption("BOX2Z");

    h3D_All->SetMinimum(0);
    h3D_Full->SetMinimum(0);
    h3D_GroupResolved->SetMinimum(0);
    h3D_Partial->SetMinimum(0);

    // Create trajectory visualization objects
    TPolyLine3D* trajectoryLine = nullptr;
    TF1* trajX_vs_Z = nullptr;
    TF1* trajY_vs_Z = nullptr;
    TPolyLine3D* thetaZeroLine = nullptr;
    TPolyLine3D* phiZeroLine = nullptr;
    
    // Create reference lines
    thetaZeroLine = new TPolyLine3D(2);
    thetaZeroLine->SetPoint(0, 24, 4, 0);
    thetaZeroLine->SetPoint(1, 24, 4, 24);
    thetaZeroLine->SetLineColor(kBlue);
    thetaZeroLine->SetLineWidth(2);
    thetaZeroLine->SetLineStyle(2);
    
    phiZeroLine = new TPolyLine3D(2);
    phiZeroLine->SetPoint(0, 48, 4, 12);
    phiZeroLine->SetPoint(1, 0, 4, 12);
    phiZeroLine->SetLineColor(kGreen);
    phiZeroLine->SetLineWidth(2);
    phiZeroLine->SetLineStyle(2);
    
    if (trajectory.valid) {
        double zMin = 0;
        double zMax = 48;
        
        for (const auto& hit : hits3D) {
            if (hit.confidence >= 0.5) {
                zMin = std::min(zMin, hit.z - 2.0);
                zMax = std::max(zMax, hit.z + 2.0);
            }
        }
        
        if (std::abs(trajectory.vz) > 0.01) {
            trajX_vs_Z = new TF1("trajX_vs_Z", 
                                Form("%f + (x - %f) * %f / %f", 
                                     trajectory.x0, trajectory.z0, trajectory.vx, trajectory.vz),
                                zMin, zMax);
            trajX_vs_Z->SetLineColor(kRed);
            trajX_vs_Z->SetLineWidth(2);
            
            trajY_vs_Z = new TF1("trajY_vs_Z", 
                                Form("%f + (x - %f) * %f / %f", 
                                     trajectory.y0, trajectory.z0, trajectory.vy, trajectory.vz),
                                zMin, zMax);
            trajY_vs_Z->SetLineColor(kRed);
            trajY_vs_Z->SetLineWidth(2);
        }
        
        // Create polyline for 3D visualization
        int nPoints = 100;
        trajectoryLine = new TPolyLine3D(nPoints);
        
        double tMin = 1e9, tMax = -1e9;
        for (const auto& hit : hits3D) {
            if (hit.confidence >= 0.8) {
                double t = (hit.x - trajectory.x0) * trajectory.vx + 
                          (hit.y - trajectory.y0) * trajectory.vy + 
                          (hit.z - trajectory.z0) * trajectory.vz;
                tMin = std::min(tMin, t);
                tMax = std::max(tMax, t);
            }
        }
        
        double extension = 3.0;
        tMin -= extension;
        tMax += extension;
        
        for (int i = 0; i < nPoints; i++) {
            double t = tMin + (tMax - tMin) * i / (nPoints - 1);
            double x = trajectory.x0 + t * trajectory.vx;
            double y = trajectory.y0 + t * trajectory.vy;
            double z = trajectory.z0 + t * trajectory.vz;
            
            trajectoryLine->SetPoint(i, z, y, x);
        }
        
        trajectoryLine->SetLineColor(kRed);
        trajectoryLine->SetLineWidth(3);
    }

    // Write histograms
    h3D_Full->Write();
    h3D_GroupResolved->Write();
    h3D_Partial->Write();
    h3D_All->Write();
    h3D_Alpha->Write();
    
    if (trajectoryLine) {
        trajectoryLine->Write("trajectory");
    }
    if (trajX_vs_Z) {
        trajX_vs_Z->Write();
    }
    if (trajY_vs_Z) {
        trajY_vs_Z->Write();
    }
    
    thetaZeroLine->Write("thetaZeroLine");
    phiZeroLine->Write("phiZeroLine");
    
    // Save tree with individual view charges
    TTree* tree3D = new TTree("Hits3D", "Reconstructed 3D Hits with Individual View Charges");
    
    Double_t t_x, t_y, t_z, t_charge, t_confidence;
    Double_t t_timeXY, t_timeXZ, t_timeZY;
    Double_t t_chargeXY, t_chargeXZ, t_chargeZY;
    Double_t t_originalChargeXY, t_originalChargeXZ, t_originalChargeZY;
    Int_t t_nViews, t_redistributed;
    Char_t t_matchType[100];
    
    tree3D->Branch("x", &t_x, "x/D");
    tree3D->Branch("y", &t_y, "y/D");
    tree3D->Branch("z", &t_z, "z/D");
    tree3D->Branch("charge", &t_charge, "charge/D");
    tree3D->Branch("confidence", &t_confidence, "confidence/D");
    tree3D->Branch("timeXY", &t_timeXY, "timeXY/D");
    tree3D->Branch("timeXZ", &t_timeXZ, "timeXZ/D");
    tree3D->Branch("timeZY", &t_timeZY, "timeZY/D");
    tree3D->Branch("chargeXY", &t_chargeXY, "chargeXY/D");
    tree3D->Branch("chargeXZ", &t_chargeXZ, "chargeXZ/D");
    tree3D->Branch("chargeZY", &t_chargeZY, "chargeZY/D");
    tree3D->Branch("originalChargeXY", &t_originalChargeXY, "originalChargeXY/D");
    tree3D->Branch("originalChargeXZ", &t_originalChargeXZ, "originalChargeXZ/D");
    tree3D->Branch("originalChargeZY", &t_originalChargeZY, "originalChargeZY/D");
    tree3D->Branch("nViews", &t_nViews, "nViews/I");
    tree3D->Branch("redistributed", &t_redistributed, "redistributed/I");
    tree3D->Branch("matchType", t_matchType, "matchType/C");
    
    for (const auto& hit : hits3D) {
        t_x = hit.x;
        t_y = hit.y;
        t_z = hit.z;
        t_charge = hit.charge;
        t_confidence = hit.confidence;
        t_timeXY = hit.timeXY;
        t_timeXZ = hit.timeXZ;
        t_timeZY = hit.timeZY;
        t_chargeXY = hit.chargeXY;
        t_chargeXZ = hit.chargeXZ;
        t_chargeZY = hit.chargeZY;
        t_originalChargeXY = hit.originalChargeXY;
        t_originalChargeXZ = hit.originalChargeXZ;
        t_originalChargeZY = hit.originalChargeZY;
        t_nViews = hit.nViews;
        t_redistributed = hit.redistributed ? 1 : 0;
        strcpy(t_matchType, hit.matchType.c_str());
        
        tree3D->Fill();
    }
    
    tree3D->Write();
    
    // Save trajectory parameters
 TTree* trajTree = new TTree("Trajectory", "Fitted Trajectory Parameters with PCA Analysis");
    
    // Original trajectory parameters
    Double_t tr_x0, tr_y0, tr_z0, tr_vx, tr_vy, tr_vz, tr_theta, tr_phi;
    Int_t tr_valid, tr_nHits, tr_isSingleTrack;
    
    // PCA parameters 
    Double_t pca_centroid_x, pca_centroid_y, pca_centroid_z;
    Double_t pca_pc1_x, pca_pc1_y, pca_pc1_z;
    Double_t pca_pc2_x, pca_pc2_y, pca_pc2_z;
    Double_t pca_pc3_x, pca_pc3_y, pca_pc3_z;
    Double_t pca_eigenvalues[3], pca_explainedVariance[3], pca_cumulativeVariance[3];
    Double_t pca_linearity, pca_planarity, pca_trackWidth, pca_trackThickness, pca_totalVariance;
    Double_t pca_rmsResidual, pca_maxResidual, pca_confidenceScore;
    Int_t pca_nHighConfidenceHits, pca_nOutliers;
    Double_t pca_weightedCentroidDistance, pca_outlierThreshold;
    Double_t pca_meanLongitudinalDistance, pca_meanTransverseDistance, pca_meanNormalDistance;
    Int_t pca_valid;
    
    // Branch the original parameters
    trajTree->Branch("x0", &tr_x0, "x0/D");
    trajTree->Branch("y0", &tr_y0, "y0/D");
    trajTree->Branch("z0", &tr_z0, "z0/D");
    trajTree->Branch("vx", &tr_vx, "vx/D");
    trajTree->Branch("vy", &tr_vy, "vy/D");
    trajTree->Branch("vz", &tr_vz, "vz/D");
    trajTree->Branch("theta", &tr_theta, "theta/D");
    trajTree->Branch("phi", &tr_phi, "phi/D");
    trajTree->Branch("valid", &tr_valid, "valid/I");
    trajTree->Branch("nHits", &tr_nHits, "nHits/I");
    trajTree->Branch("isSingleTrack", &tr_isSingleTrack, "isSingleTrack/I");
    
    // Branch the PCA parameters
    trajTree->Branch("pca_valid", &pca_valid, "pca_valid/I");
    trajTree->Branch("pca_centroid_x", &pca_centroid_x, "pca_centroid_x/D");
    trajTree->Branch("pca_centroid_y", &pca_centroid_y, "pca_centroid_y/D");
    trajTree->Branch("pca_centroid_z", &pca_centroid_z, "pca_centroid_z/D");
    trajTree->Branch("pca_pc1_x", &pca_pc1_x, "pca_pc1_x/D");
    trajTree->Branch("pca_pc1_y", &pca_pc1_y, "pca_pc1_y/D");
    trajTree->Branch("pca_pc1_z", &pca_pc1_z, "pca_pc1_z/D");
    trajTree->Branch("pca_pc2_x", &pca_pc2_x, "pca_pc2_x/D");
    trajTree->Branch("pca_pc2_y", &pca_pc2_y, "pca_pc2_y/D");
    trajTree->Branch("pca_pc2_z", &pca_pc2_z, "pca_pc2_z/D");
    trajTree->Branch("pca_pc3_x", &pca_pc3_x, "pca_pc3_x/D");
    trajTree->Branch("pca_pc3_y", &pca_pc3_y, "pca_pc3_y/D");
    trajTree->Branch("pca_pc3_z", &pca_pc3_z, "pca_pc3_z/D");
    trajTree->Branch("pca_eigenvalues", pca_eigenvalues, "pca_eigenvalues[3]/D");
    trajTree->Branch("pca_explainedVariance", pca_explainedVariance, "pca_explainedVariance[3]/D");
    trajTree->Branch("pca_cumulativeVariance", pca_cumulativeVariance, "pca_cumulativeVariance[3]/D");
    trajTree->Branch("pca_linearity", &pca_linearity, "pca_linearity/D");
    trajTree->Branch("pca_planarity", &pca_planarity, "pca_planarity/D");
    trajTree->Branch("pca_trackWidth", &pca_trackWidth, "pca_trackWidth/D");
    trajTree->Branch("pca_trackThickness", &pca_trackThickness, "pca_trackThickness/D");
    trajTree->Branch("pca_totalVariance", &pca_totalVariance, "pca_totalVariance/D");
    trajTree->Branch("pca_rmsResidual", &pca_rmsResidual, "pca_rmsResidual/D");
    trajTree->Branch("pca_maxResidual", &pca_maxResidual, "pca_maxResidual/D");
    trajTree->Branch("pca_confidenceScore", &pca_confidenceScore, "pca_confidenceScore/D");
    trajTree->Branch("pca_nHighConfidenceHits", &pca_nHighConfidenceHits, "pca_nHighConfidenceHits/I");
    trajTree->Branch("pca_nOutliers", &pca_nOutliers, "pca_nOutliers/I");
    trajTree->Branch("pca_weightedCentroidDistance", &pca_weightedCentroidDistance, "pca_weightedCentroidDistance/D");
    trajTree->Branch("pca_outlierThreshold", &pca_outlierThreshold, "pca_outlierThreshold/D");
    trajTree->Branch("pca_meanLongitudinalDistance", &pca_meanLongitudinalDistance, "pca_meanLongitudinalDistance/D");
    trajTree->Branch("pca_meanTransverseDistance", &pca_meanTransverseDistance, "pca_meanTransverseDistance/D");
    trajTree->Branch("pca_meanNormalDistance", &pca_meanNormalDistance, "pca_meanNormalDistance/D");
    
    // Fill the tree with both trajectory and PCA data
    if (trajectory.valid) {
        // Fill trajectory parameters
        tr_x0 = trajectory.x0;
        tr_y0 = trajectory.y0;
        tr_z0 = trajectory.z0;
        tr_vx = trajectory.vx;
        tr_vy = trajectory.vy;
        tr_vz = trajectory.vz;
        tr_theta = trajectory.theta;
        tr_phi = trajectory.phi;
        tr_valid = 1;
        tr_isSingleTrack = isSingleTrack ? 1 : 0;
        
        int highConfHits = 0;
        for (const auto& hit : hits3D) {
            if (hit.confidence >= 0.5) highConfHits++;
        }
        tr_nHits = highConfHits;
        
        // Fill PCA parameters
        if (pcaResult.valid) {
            pca_valid = 1;
            pca_centroid_x = pcaResult.centroid_x;
            pca_centroid_y = pcaResult.centroid_y;
            pca_centroid_z = pcaResult.centroid_z;
            pca_pc1_x = pcaResult.pc1_x;
            pca_pc1_y = pcaResult.pc1_y;
            pca_pc1_z = pcaResult.pc1_z;
            pca_pc2_x = pcaResult.pc2_x;
            pca_pc2_y = pcaResult.pc2_y;
            pca_pc2_z = pcaResult.pc2_z;
            pca_pc3_x = pcaResult.pc3_x;
            pca_pc3_y = pcaResult.pc3_y;
            pca_pc3_z = pcaResult.pc3_z;
            
            for (int i = 0; i < 3; i++) {
                pca_eigenvalues[i] = pcaResult.eigenvalues[i];
                pca_explainedVariance[i] = pcaResult.explainedVariance[i];
                pca_cumulativeVariance[i] = pcaResult.cumulativeVariance[i];
            }
            
            pca_linearity = pcaResult.linearity;
            pca_planarity = pcaResult.planarity;
            pca_trackWidth = pcaResult.trackWidth;
            pca_trackThickness = pcaResult.trackThickness;
            pca_totalVariance = pcaResult.totalVariance;
            pca_rmsResidual = pcaResult.rmsResidual;
            pca_maxResidual = pcaResult.maxResidual;
            pca_confidenceScore = pcaResult.confidenceScore;
            pca_nHighConfidenceHits = pcaResult.nHighConfidenceHits;
            pca_nOutliers = pcaResult.nOutliers;
            pca_weightedCentroidDistance = pcaResult.weightedCentroidDistance;
            pca_outlierThreshold = pcaResult.outlierThreshold;
            pca_meanLongitudinalDistance = pcaResult.meanLongitudinalDistance;
            pca_meanTransverseDistance = pcaResult.meanTransverseDistance;
            pca_meanNormalDistance = pcaResult.meanNormalDistance;
        } else {
            // Set PCA parameters to default values if PCA failed
            pca_valid = 0;
            pca_centroid_x = pca_centroid_y = pca_centroid_z = 0;
            pca_pc1_x = pca_pc1_y = pca_pc1_z = 0;
            pca_pc2_x = pca_pc2_y = pca_pc2_z = 0;
            pca_pc3_x = pca_pc3_y = pca_pc3_z = 0;
            for (int i = 0; i < 3; i++) {
                pca_eigenvalues[i] = 0;
                pca_explainedVariance[i] = 0;
                pca_cumulativeVariance[i] = 0;
            }
            pca_linearity = pca_planarity = pca_trackWidth = pca_trackThickness = 0;
            pca_totalVariance = pca_rmsResidual = pca_maxResidual = pca_confidenceScore = 0;
            pca_nHighConfidenceHits = pca_nOutliers = 0;
            pca_weightedCentroidDistance = pca_outlierThreshold = 0;
            pca_meanLongitudinalDistance = pca_meanTransverseDistance = pca_meanNormalDistance = 0;
        }
        
        trajTree->Fill();
    }
    
    trajTree->Write();
    
    // Save summary information
    TNamed eventInfo("EventInfo", Form("Event %d: %zu 3D hits reconstructed (%d high-confidence hits used for trajectory)", 
                                      eventNumber, hits3D.size(), 
                                      trajectory.valid ? tr_nHits : 0));
    eventInfo.Write();
    
    if (trajectory.valid) {
        TNamed trajInfo("TrajectoryInfo", Form("Theta=%.1f deg, Phi=%.1f deg, Entry=(%.1f,%.1f,%.1f)", 
                                              trajectory.theta, trajectory.phi, 
                                              trajectory.x0, trajectory.y0, trajectory.z0));
        trajInfo.Write();
    }
    
    fOutput->Close();
    file->Close();
    
    // std::cout << "\n3D reconstruction complete with PCA parameters saved!" << std::endl;
    // std::cout << "\n3D reconstruction complete with individual view charges!" << std::endl;
    // std::cout << "Track classification: " << (isSingleTrack ? "Single Track" : "Other") << std::endl;
    // std::cout << "Output saved to: " << outputFile << std::endl;
    // std::cout << "\nTo view in ROOT:" << std::endl;
    // std::cout << "  root " << outputFile << std::endl;
    // std::cout << "  // Method 1: Draw everything together with confidence levels" << std::endl;
    // std::cout << "  // Fitted line (red solid)" << std::endl;   
    // std::cout << "  // theta=0 reference (blue dashed)" << std::endl;
    // std::cout << "  // phi=0 reference (green dashed)" << std::endl;
    // std::cout << "  h3D_All->Draw(\"BOX2Z\")" << std::endl;
    // std::cout << "  TPolyLine3D *traj = (TPolyLine3D*)gDirectory->Get(\"trajectory\")" << std::endl;
    // std::cout << "  traj->SetLineColor(2)" << std::endl;
    // std::cout << "  traj->SetLineWidth(3)" << std::endl;
    // std::cout << "  traj->Draw()" << std::endl;
    // std::cout << "  TPolyLine3D *theta0 = (TPolyLine3D*)gDirectory->Get(\"thetaZeroLine\")" << std::endl;
    // std::cout << "  theta0->Draw()" << std::endl;
    // std::cout << "  TPolyLine3D *phi0 = (TPolyLine3D*)gDirectory->Get(\"phiZeroLine\")" << std::endl;
    // std::cout << "  phi0->Draw()" << std::endl;
    // std::cout << "  " << std::endl;
    // std::cout << "  // Method 2: View hits by type" << std::endl;
    // std::cout << "  h3D_Full->Draw(\"BOX2Z\")              // Perfect 3-view hits" << std::endl;
    // std::cout << "  h3D_GroupResolved->Draw(\"BOX2Z\")     // Group-resolved hits (using 3-view references)" << std::endl;
    // std::cout << "  h3D_Partial->Draw(\"BOX2Z\")           // Remaining unresolved 2-view hits" << std::endl;
    // std::cout << "  " << std::endl;
    // std::cout << "  // Method 3: View hits by confidence level using h3D_Alpha" << std::endl;
    // std::cout << "  h3D_Alpha->Draw(\"BOX2Z\")" << std::endl;
    // std::cout << "  // This shows: 1.0=Full hits, 0.9/0.7/0.5/0.3=Resolved hits, 0.1=Unresolved 2-view" << std::endl;
    
    delete event;
    file->Close();
    exit(0);
}